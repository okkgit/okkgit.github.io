(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{341:function(v,_,i){"use strict";i.r(_);var l=i(14),s=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[v._v("#")]),v._v(" Redis")]),v._v(" "),_("p",[v._v("高性能 key-value 数据库")]),v._v(" "),_("ul",[_("li",[v._v("作为内存级数据库，支持持久化")]),v._v(" "),_("li",[v._v("支持多种数据类型")]),v._v(" "),_("li",[v._v("redis,支持主从备份 master-slave")])]),v._v(" "),_("h2",{attrs:{id:"redis支持的数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis支持的数据类型"}},[v._v("#")]),v._v(" Redis支持的数据类型")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("String类型，二进制安全，可以存储二进制文件，图片等")])]),v._v(" "),_("li",[_("p",[v._v("Hash，string类型的 key value对集合（非常适合存储对象）")])]),v._v(" "),_("li",[_("p",[v._v("List,按照插入顺序排序的string类型列表")])]),v._v(" "),_("li",[_("p",[v._v("Set,是通过hash实现的String类型无序集合（hash O(1)时间复杂的增删改查）")])]),v._v(" "),_("li",[_("p",[v._v("zset，有序集合，类似set，string的集合，不可以重复，但要关联double类型的分数")])]),v._v(" "),_("li",[_("p",[v._v("三种不常用的类型")]),v._v(" "),_("ul",[_("li",[v._v("geo 存放地图数据包括经纬度城市。。。")]),v._v(" "),_("li",[v._v("hyperloglog 不精确的去重计数")]),v._v(" "),_("li",[v._v("bitmap 位图，有限集合")])])])]),v._v(" "),_("h2",{attrs:{id:"redis的两种持久化方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis的两种持久化方法"}},[v._v("#")]),v._v(" Redis的两种持久化方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("为了防止断电等情况，redis数据丢失，持久化，把数据存放到磁盘。")])]),v._v(" "),_("li",[_("p",[v._v("RDB， redis-database, 快照的方式")]),v._v(" "),_("ul",[_("li",[v._v("save命令，会阻塞，不常用")]),v._v(" "),_("li",[v._v("bgsave命令，异步操作，rdb中一般会用这种")]),v._v(" "),_("li",[v._v('自动触发，eg. 配置文件内"save m n", m秒内数据n次修改，触发bgsave')])])]),v._v(" "),_("li",[_("p",[v._v("AOF, append-only-file,每一次收到写命令，write到文件中，就是类似记录日志一样。")]),v._v(" "),_("ul",[_("li",[v._v("触发机制\n"),_("ul",[_("li",[v._v("每次都同步，只要发生变化（曾删改），就会同步，性能最差大数据同步好")]),v._v(" "),_("li",[v._v("每一秒同步，异步实现，但可能宕机造成一秒内数据丢失")]),v._v(" "),_("li",[v._v("不同步")])])]),v._v(" "),_("li",[v._v("优点\n"),_("ul",[_("li",[v._v("更好的数据安全性")])])]),v._v(" "),_("li",[v._v("缺点\n"),_("ul",[_("li",[v._v("aof文件比rdb更大")]),v._v(" "),_("li",[v._v("qfs会相对低一些，但也不会太低")])])])]),v._v(" "),_("h2",{attrs:{id:"resp协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#resp协议"}},[v._v("#")]),v._v(" RESP协议")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("RESP 是redis客户端和服务端之前使用的一种通讯协议；")])]),v._v(" "),_("li",[_("p",[v._v("RESP 的特点：实现简单、快速解析、可读性好")]),v._v(" "),_("ul",[_("li",[v._v("'+' 开头的简单字符串")]),v._v(" "),_("li",[v._v("'-' 开头错误")]),v._v(" "),_("li",[v._v("':' 开头整形")]),v._v(" "),_("li",[v._v("'$' 批量字符串")]),v._v(" "),_("li",[v._v("'*' 开头数组")])])])]),v._v(" "),_("h2",{attrs:{id:"redis-架构模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-架构模式"}},[v._v("#")]),v._v(" Redis 架构模式")]),v._v(" "),_("ul",[_("li",[v._v("单机模式\n"),_("ul",[_("li",[v._v("多个客户端访问一台redis\n"),_("ul",[_("li",[v._v("内容有限（一台计算机考虑成本的化内存就不会太大）")]),v._v(" "),_("li",[v._v("处理能力有限")]),v._v(" "),_("li",[v._v("不高可用（出故障咋整）")])])])])]),v._v(" "),_("li",[v._v("主从复制 master - slave （一台主机多台从机，数据相同，一直在同步）\n"),_("ul",[_("li",[v._v("master / slave 角色")]),v._v(" "),_("li",[v._v("主从数据相同")]),v._v(" "),_("li",[v._v("降低主机读取压力（从slave读取）")]),v._v(" "),_("li",[v._v("存在问题：\n"),_("ul",[_("li",[v._v("高可用无法保障")]),v._v(" "),_("li",[v._v("写压力大（只能向master写，压力就大了）")])])])])])])]),v._v(" "),_("li",[_("p",[v._v("哨兵模式 💯 Sentinel\n- Sentinel（哨兵） 单独拿出一组服务器不断的监控主从服务器，必要时候故障修复转移\n- 监控，sentinel不断检查主从服务器是否正常工作\n- 通知，发现服务器出问题，可以向管理员或其他程序发送通知\n- 主服务器出问题，回尝试故障迁移\n- 特点\n- 高可用\n- 监控每个节点\n- 自动故障迁移\n- 问题\n- 主从模式切换需要时间可能回丢失数据")]),v._v(" "),_("ul",[_("li",[v._v("集群,直连 Redis-Cluster, redis 3.0后支持\n"),_("ul",[_("li",[v._v("无中心架构， 没有代理"),_("code",[v._v("proxy")]),v._v(" 层\n"),_("ul",[_("li",[v._v("数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。")]),v._v(" "),_("li",[v._v("可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。")]),v._v(" "),_("li",[v._v("高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本")])])])])])])])]),v._v(" "),_("h2",{attrs:{id:"redis-分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式锁"}},[v._v("#")]),v._v(" Redis 分布式锁")]),v._v(" "),_("h2",{attrs:{id:"缓存穿透-故意大量查询不存在的数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透-故意大量查询不存在的数据"}},[v._v("#")]),v._v(" 缓存穿透（故意大量查询不存在的数据）")]),v._v(" "),_("ul",[_("li",[v._v("数据不存在，会造成，访问DB后无法缓存到redis，大量访问不存在在的数据，后端DB查询压力比较大")]),v._v(" "),_("li",[v._v("解决办法\n"),_("ul",[_("li",[v._v("数据不存在也缓存，设置短的过期时间，或数据真的存在时清除")]),v._v(" "),_("li",[v._v("根据业务过滤，考虑布隆过滤器 bitmap")])])])]),v._v(" "),_("h2",{attrs:{id:"缓存击穿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[v._v("#")]),v._v(" 缓存击穿")]),v._v(" "),_("ul",[_("li",[v._v("访问量比较大的数据缓存过期，导致多协程并发的访问数据库同样的数据。")]),v._v(" "),_("li",[v._v("解决办法\n"),_("ul",[_("li",[v._v("锁")]),v._v(" "),_("li",[v._v("热点数据过期时间策略")])])])]),v._v(" "),_("h2",{attrs:{id:"缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),_("ul",[_("li",[v._v("服务器重启或缓存同时大量失效时，导致服务器需要大量从DB加载数据到缓存，压力过大，甚至宕机。")]),v._v(" "),_("li",[v._v("解决办法\n"),_("ul",[_("li",[v._v("限制读取访问数量，加锁，队列等方法，")]),v._v(" "),_("li",[v._v("缓存过期时间随机一些，比入给同一批的缓存时间每个随机增加（0到5秒），使其不在同一时刻爆发。")])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);