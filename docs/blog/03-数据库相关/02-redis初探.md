---
sidebar: auto
---

# Redis
高性能 key-value 数据库
- 作为内存级数据库，支持持久化
- 支持多种数据类型
- redis,支持主从备份 master-slave

## Redis支持的数据类型
- String类型，二进制安全，可以存储二进制文件，图片等
- Hash，string类型的 key value对集合（非常适合存储对象）
- List,按照插入顺序排序的string类型列表
- Set,是通过hash实现的String类型无序集合（hash O(1)时间复杂的增删改查）
- zset，有序集合，类似set，string的集合，不可以重复，但要关联double类型的分数

## Redis的两种持久化方法

- 为了防止断电等情况，redis数据丢失，持久化，把数据存放到磁盘。

- RDB， redis-database, 快照的方式

  - save命令，会阻塞，不常用
  - bgsave命令，异步操作，rdb中一般会用这种
  - 自动触发，eg. 配置文件内"save m n", m秒内数据n次修改，触发bgsave

- AOF, append-only-file,每一次收到写命令，write到文件中，就是类似记录日志一样。

  - 触发机制
    - 每次都同步，只要发生变化（曾删改），就会同步，性能最差大数据同步好
    - 每一秒同步，异步实现，但可能宕机造成一秒内数据丢失
    - 不同步
  - 优点
    - 更好的数据安全性
  - 缺点
    - aof文件比rdb更大
    - qfs会相对低一些，但也不会太低

  ## RESP协议

  - RESP 是redis客户端和服务端之前使用的一种通讯协议；

  - RESP 的特点：实现简单、快速解析、可读性好
    - '+' 开头的简单字符串
    - '-' 开头错误
    - ':' 开头整形
    - '$' 批量字符串
    - '*' 开头数组

  ## Redis 架构模式

  - 单机模式
    - 多个客户端访问一台redis
      - 内容有限（一台计算机考虑成本的化内存就不会太大）
      - 处理能力有限
      - 不高可用（出故障咋整）
  - 主从复制 master - slave （一台主机多台从机，数据相同，一直在同步）
    - master / slave 角色
    - 主从数据相同
    - 降低主机读取压力（从slave读取）
    - 存在问题：
      - 高可用无法保障
      - 写压力大（只能向master写，压力就大了）
- 哨兵模式 :100: Sentinel
      - Sentinel（哨兵） 单独拿出一组服务器不断的监控主从服务器，必要时候故障修复转移
        - 监控，sentinel不断检查主从服务器是否正常工作
        - 通知，发现服务器出问题，可以向管理员或其他程序发送通知
        - 主服务器出问题，回尝试故障迁移
        - 特点
          - 高可用
          - 监控每个节点
          - 自动故障迁移
        - 问题
          - 主从模式切换需要时间可能回丢失数据
  - 集群,直连 Redis-Cluster, redis 3.0后支持
    - 无中心架构， 没有代理`proxy` 层
      - 数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。
      - 可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。
      - 高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本

## Redis 分布式锁



## 缓存穿透（故意大量查询不存在的数据）

- 数据不存在，会造成，访问DB后无法缓存到redis，大量访问不存在在的数据，后端DB查询压力比较大
- 解决办法
  - 数据不存在也缓存，设置短的过期时间，或数据真的存在时清除
  - 根据业务过滤，考虑布隆过滤器 bitmap

## 缓存击穿

- 访问量比较大的数据缓存过期，导致多协程并发的访问数据库同样的数据。
- 解决办法
  - 锁
  - 热点数据过期时间策略

## 缓存雪崩

- 服务器重启或缓存同时大量失效时，导致服务器需要大量从DB加载数据到缓存，压力过大，甚至宕机。
- 解决办法
  - 限制读取访问数量，加锁，队列等方法，
  - 缓存过期时间随机一些，比入给同一批的缓存时间每个随机增加（0到5秒），使其不在同一时刻爆发。